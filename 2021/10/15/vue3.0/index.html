<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>vue3.0知识点 | 叶子的知识树</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="watch 与watchEffect的区别watchwatch用来监听特定的数据源，并在回调函数中执行。 1watch(source,callback,options)  具体的用法： 123456789101112131415161718192021&#x2F;&#x2F;无论是ref定义的对象还是reactive定义的对象，要监听对象中的属性值变化，使用下面的方法const data &#x3D; ref(&amp;#123;pa">
<meta property="og:type" content="article">
<meta property="og:title" content="vue3.0知识点">
<meta property="og:url" content="https://qq-leaves.github.io/2021/10/15/vue3.0/index.html">
<meta property="og:site_name" content="叶子的知识树">
<meta property="og:description" content="watch 与watchEffect的区别watchwatch用来监听特定的数据源，并在回调函数中执行。 1watch(source,callback,options)  具体的用法： 123456789101112131415161718192021&#x2F;&#x2F;无论是ref定义的对象还是reactive定义的对象，要监听对象中的属性值变化，使用下面的方法const data &#x3D; ref(&amp;#123;pa">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://qq-leaves.github.io/Users/zlj/Library/Application%20Support/typora-user-images/image-20211007195037877.png">
<meta property="article:published_time" content="2021-10-15T06:47:28.855Z">
<meta property="article:modified_time" content="2021-10-15T08:05:33.936Z">
<meta property="article:author" content="叶子">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://qq-leaves.github.io/Users/zlj/Library/Application%20Support/typora-user-images/image-20211007195037877.png">
  
    <link rel="alternate" href="/atom.xml" title="叶子的知识树" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">叶子的知识树</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://qq-leaves.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-vue3.0" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/15/vue3.0/" class="article-date">
  <time class="dt-published" datetime="2021-10-15T06:47:28.855Z" itemprop="datePublished">2021-10-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      vue3.0知识点
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="watch-与watchEffect的区别"><a href="#watch-与watchEffect的区别" class="headerlink" title="watch 与watchEffect的区别"></a>watch 与watchEffect的区别</h2><h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><p>watch用来监听特定的数据源，并在回调函数中执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch(source,callback,options)</span><br></pre></td></tr></table></figure>

<p>具体的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//无论是ref定义的对象还是reactive定义的对象，要监听对象中的属性值变化，使用下面的方法</span><br><span class="line">const data = ref(&#123;pageNum:1&#125;)</span><br><span class="line">const add = ()=&gt;&#123;</span><br><span class="line">  data.value.pageNum++</span><br><span class="line">&#125;</span><br><span class="line">add()</span><br><span class="line">watch(() =&gt; data.value.pageNum, (val, oldVal) =&gt; &#123;</span><br><span class="line">   if (val !== oldVal) &#123;</span><br><span class="line">     data.value.pageNum = val</span><br><span class="line">     //当页码不一样调取接口</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//如果监听的是ref定义的简单数据类型，则watch的第一个参数直接是你要监听的那个变量：</span><br><span class="line">var count = ref(0)</span><br><span class="line">watch(count, (val, oldVal) =&gt; &#123;</span><br><span class="line">   if (val !== oldVal) &#123;</span><br><span class="line">     data.value.pageNum = val</span><br><span class="line">     //当页码不一样调取接口</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可能有人会觉得直接每次监听，都需要写一遍watch函数，很麻烦。那vue3.0也提供了多个数据的监听</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch([()=&gt;data.value.pageNum,count],([curPage,oldPage],[curCount,oldCount])=&gt;&#123;</span><br><span class="line">	//在这里做监听变化后的事情就ok了</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当然，如果你想一开始就在回调函数中做一些动作那就在第三个参数中使用immediate: true。</p>
<p>如果你监听的是复杂的数据类型，那就可以用deep:true对数据施行深度监听。</p>
<h4 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h4><p>在讲watchEffect之前，我们先看看在项目中我们怎么去用它？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const childOne = ref(null)</span><br><span class="line">watchEffect(()=&gt;&#123;</span><br><span class="line">        console.log(&#x27;打印&#x27;,childOne.value)</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        flush:&#x27;post&#x27;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>![image-20210930155922138](/Users/zlj/Library/Application Support/typora-user-images/image-20210930155922138.png)</p>
<p>这里我加了flush这个属性，这个属性，你从打印的日志就可以知道了，如果不加的话，就会打印模版还未挂在的值，加了flush一定是挂在完毕才会打印</p>
<h4 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h4><p>停止监听，看到这里是不是觉得，写vue2.0的时候，有时候想停止监听却无计可施，只能眼巴巴的等到组件被销毁的时候才能停止。是不是很气呢？这不vue3.0就给你提供了stop函数来停止监听。</p>
<p>那如何停止监听呢，比较简单就是再调一次你的watch()监听函数的返回值。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const stop=watch(count, (val, oldVal) =&gt; &#123;</span><br><span class="line">   if (val !== oldVal) &#123;</span><br><span class="line">     data.value.pageNum = val</span><br><span class="line">     //当页码不一样调取接口</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">//然后在某个函数中调用stop()函数，监听就停止了</span><br></pre></td></tr></table></figure>

<p>整篇文章的题目是：watch 与watchEffect的区别，还是要点一下题的，哈哈</p>
<p>first：watchEffect不需要指定监听的属性，自动收集依赖；</p>
<p>second:watchEffect拿不到旧值；watch可以拿到旧值</p>
<p>third:watchEffect在组件第一次就会收集依赖，然后收集到的依赖发生了变化，回调才会再次执行；watch就不是了。一开始就指定了依赖。</p>
<p>1.getcurrentInstance:获取组件实例；development，即开发环境下才能获取到当前组件的实例</p>
<p>2.setup()中的参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1）props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</span><br><span class="line"></span><br><span class="line">（2）context：上下文对象</span><br><span class="line">  attrs: 值为对象，包含：组件外部传递过来，但没有在     props配置中声明的属性, 相当于 this.$attrs。</span><br><span class="line">  slots: 收到的插槽内容, 相当于 this.$slots。</span><br><span class="line">  emit: 分发自定义事件的函数, 相当于 this.$emit。</span><br></pre></td></tr></table></figure>

<p>3.slot:组件插槽（内容分发）</p>
<p>vue的slot分为匿名插槽、具名插槽、作用域插槽</p>
<p>在父组件中使用v-slot:btns让父组件的内容在子组件中显示。</p>
<p>具名插槽：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--  子组件中：--&gt;</span><br><span class="line">&lt;slot name=&quot;title&quot;&gt;&lt;/slot&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--  父组件中使用：--&gt;</span><br><span class="line">&lt;template slot=&quot;title&quot;&gt;</span><br><span class="line">    &lt;h1&gt;歌曲：成都&lt;/h1&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- 子组件上传递数据 --&gt;</span><br><span class="line">&lt;slot name=&quot;content&quot; :data=&quot;data&quot;&gt;&lt;/slot&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            data:[&quot;走过来人来人往&quot;,&quot;不喜欢也得欣赏&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 父组件中使用 --&gt;</span><br><span class="line">&lt;template slot=&quot;content&quot; slot-scope=&quot;scoped&quot;&gt;</span><br><span class="line">    &lt;div v-for=&quot;item in scoped.data&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在vue3.0中将slot和slot-scope合并统一使用：v-slot</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-slot:content=&quot;scoped&quot;&gt;</span><br><span class="line">    &lt;div v-for=&quot;item in scoped.data&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;template&gt;</span><br></pre></td></tr></table></figure>

<p>4.render函数的使用</p>
<p>动态创建template的内容。在使用render函数时，在.vue文件中需要把template标签去掉，只保留逻辑层。</p>
<p>直接使用render函数构建DOM。vue就免去了转译的过程。当使用render函数描述虚拟DOM时，vue提供一个函数。 这个函数的名字叫createElement。还有约定的简写叫h.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">写法一：render(h)&#123;        return h(&#x27;div&#x27;,&#123;//第二个参数            class:&#123;                &#x27;is-red&#x27;: this.isRed            &#125;        &#125;,        //第三个参数          [h(&#x27;p&#x27;,&#x27;这是一个render&#x27;)]          );  &#125;  写法二：  render(h, context) &#123;    return (    &lt;div class=&#x27;m-chartConInner&#x27; ref=&#x27;content&#x27;&gt;       &lt;p&gt;这是一个render&lt;/p&gt;    &lt;/div&gt;)  &#125;  编译出来：  &lt;div :class=&quot;&#123;&#x27;is-red&#x27;:isRed &#125;&quot;&gt;       &lt;p&gt;这是一个render&lt;/p&gt;  &lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>5.cancelToken取消请求</p>
<p>cancelToken是axios用来取消请求的API。</p>
<p>那为什么要取消呢？是由于浏览器的请求的响应时间存在不确定性，请求次数过多可能较早发起的请求会比较晚的响应。所以要为了提升页面性能减少不必要的等待，我们需要取消不需要等待的较早的请求。</p>
<p>那种过多的请求是无意义且浪费性能的呢？</p>
<p>比如：（1）菜单的路由页面跳转、tab栏的高频切换；</p>
<p>​            （2）搜索框的change事件模糊匹配时，短时间发送多个ajax请求，返回数据并不是最想要的。</p>
<h4 id="注意：cancel-token-并不是意义上的取消，请求还是会到服务器，只是浏览器进行处理。"><a href="#注意：cancel-token-并不是意义上的取消，请求还是会到服务器，只是浏览器进行处理。" class="headerlink" title="注意：cancel token 并不是意义上的取消，请求还是会到服务器，只是浏览器进行处理。"></a>注意：cancel token 并不是意义上的取消，请求还是会到服务器，只是浏览器进行处理。</h4><p>那如何创建cancelToken呢？具体呢有两种写法：</p>
<p>第一种：使用CancelToken.source工厂方式创建canceltoken:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const cancelToken = axios.CancelToken;const source = cancelToken.source();axios.get(&#x27;/**/**&#x27;,&#123;	cancelToken:source.token&#125;).catch(function(thrown)=&gt;&#123;   if(aixos.isCancel(thrown))&#123;     //取消请求，打印日志    &#125;else&#123;     //处理错误    &#125;&#125;)source.cancel(&quot;取消&quot;)//取消请求，参数可选</span><br></pre></td></tr></table></figure>

<p>第二种：通过传递一个executor函数到CancelToken的构造函数来创建cancelToken</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const cancelToken = axios.CancelToken;let cancel;axios.post(&quot;**/**&quot;,&#123;name:&quot;11&quot;&#125;,&#123;	cancelToken:new cancelToken(function executor(c)&#123;	//executor 函数接收一个cancel函数作为参数		cancel = c;	&#125;)&#125;)cancel();//取消请求</span><br></pre></td></tr></table></figure>

<p>那么我们在项目中如何应用来取消重复的请求呢？我们可以在executor函数中将当前的请求地址，添加到一个数组中。然后等下次请求的时候，判断当前的请求是否存在：已经存在则直接取消。</p>
<p>这里需要注意：只使用url作为key,不惧有唯一性，也并不准确；所以我们需要使用当前请求的全部信息去生成唯一的key。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//根据当前的请求信息生成唯一的keyfunciton onlyKey = function(config)&#123; const &#123;url,method,params,data&#125; = config; return `$&#123;url&#125;$&#123;method&#125;$&#123;JSON.stringify(params)&#125;$&#123;JSON.stringify(data)&#125;`&#125;const pendingList = new Map();//添加请求信息到pendingList:function addPending (config)&#123;config.cancelToken = new cancelToken(c=&gt;&#123;  if(!pendingList.has(key))&#123;     pendingList.set(key,c)    &#125;  &#125;)&#125;//检查是否存在重复请求,存在就删除重复的请求const removePending = (config) =&gt; &#123;  //根据当前的请求信息生成唯一的key  if(pendingList.has(key))&#123;     const cancelToken = pendingRequest.get(key);     cancelToken(key);     pendingRequest.delete(key);    &#125;  &#125;)&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>（1）第一条请求永远不会被取消，因为还未将其添加到pendingList中存储。</p>
<p>（2）最好在路由跳转前判断如果不是当前的路由，移除当前pendingList等待的请求。</p>
<p>看了如何在项目中应用啦！有兴趣的话跟我一起了解一下源码鸭！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var Cancel = require(&#x27;./Cancel&#x27;);function CancelToken(executor) &#123;  if (typeof executor !== &#x27;function&#x27;) &#123;    throw new TypeError(&#x27;executor must be a function.&#x27;);  &#125;  //定义resolvePromise，创建promise实例；  //将resolve赋值给resolvePromise；使得可以在promise外部改变对象的状态  var resolvePromise;  this.promise = new Promise(function promiseExecutor(resolve) &#123;    resolvePromise = resolve;  &#125;);  //将当前CancelToken的实例赋值给token  var token = this;  //传入cancel方法，cancel方法中可以调用resolvePromise方法；来执行promise的resolve方法，改变状态  executor(function cancel(message) &#123;    if (token.reason) &#123;      // Cancellation has already been requested      return;    &#125;    token.reason = new Cancel(message);    resolvePromise(token.reason);  &#125;);&#125;/** * 如果取消被请求，则抛出一个“取消”。 */CancelToken.prototype.throwIfRequested = function throwIfRequested() &#123;  if (this.reason) &#123;    throw this.reason;  &#125;&#125;; //返回的对象中包含一个新的&#x27; CancelToken &#x27;和一个函数，该函数在被调用时，取消请求CancelToken.source = function source() &#123;  var cancel;  var token = new CancelToken(function executor(c) &#123;  //这里的c就是CancelToken中给executor传入cancel方法    cancel = c;  &#125;);  return &#123;    token: token,    cancel: cancel  &#125;;&#125;;module.exports = CancelToken;</span><br></pre></td></tr></table></figure>

<p>6.vue3.0中如何使用$emit给父组件传参呢</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emits: [&#x27;child-emit&#x27;],  setup (props, &#123; emit &#125;) &#123;    const childEmit = () =&gt; &#123;      emit(&#x27;child-emit&#x27;, &#x27;我是子组件&#x27;)    &#125;    return &#123;      childEmit    &#125;  &#125;</span><br></pre></td></tr></table></figure>

<p>7.EventBus通信</p>
<p>三种定义方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（1）抽离单独的bus.js文件，在需要使用的地方引入    import Vue from &#x27;vue&#x27;    export default new Vue()（2）直接在main.js中，挂载到全局    import Vue from &#x27;vue&#x27;    Vue.prototype.$bus = new Vue() (3) 注入到vue根对象上    import Vue from &quot;vue&quot;    new Vue(&#123;      el:&quot;#app&quot;,      data:&#123;          Bus: new Vue()        &#125;      &#125;)</span><br></pre></td></tr></table></figure>

<p>使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 在需要向外部发送自定义事件的组件内&lt;template&gt;    &lt;button @click=&quot;handlerClick&quot;&gt;按钮&lt;/button&gt;&lt;/template&gt;import Bus from &quot;./Bus.js&quot;export default&#123;    methods:&#123;        handlerClick()&#123;            // 自定义事件名 sendMsg            Bus.$emit(&quot;sendMsg&quot;, &quot;这是要向外部发送的数据&quot;)        &#125;    &#125;&#125;// 在需要接收外部事件的组件内import Bus from &quot;./Bus.js&quot;export default&#123;    mounted()&#123;        // 监听事件的触发        Bus.$on(&quot;sendMsg&quot;, data =&gt; &#123;            console.log(&quot;这是接收到的数据：&quot;, data)        &#125;)    &#125;,    beforeDestroy()&#123;        // 取消监听        Bus.$off(&quot;sendMsg&quot;)    &#125;&#125;</span><br></pre></td></tr></table></figure>



<h2 id="async-await更优雅的错误处理"><a href="#async-await更优雅的错误处理" class="headerlink" title="async/await更优雅的错误处理"></a>async/await更优雅的错误处理</h2><p>1.之前使用的错误方法就是用try{}catch{}包裹</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">try&#123;const red = await queryList()if(res.code==1)&#123;&#125;&#125;catch(err)&#123;错误处理&#125;</span><br></pre></td></tr></table></figure>

<p>2.但是对于多个异步方法的处理，引入await-to-js:<a target="_blank" rel="noopener" href="https://github.com/scopsy/await-to-js">https://github.com/scopsy/await-to-js</a></p>
<p>利用 <code>Promise</code> 的特性，分别在 <code>promise.then</code> 和 <code>promise.catch</code> 中返回不同的数组，其中 <code>fulfilled</code> 的时候返回数组第一项为 <code>null</code>，第二个是结果。<code>rejected</code> 的时候，返回数组第一项为错误信息，第二项为 <code>undefined</code>。使用的时候，判断第一项是否为空，即可知道是否有错误.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i await-to-js --save</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import to from &#x27;await-to-js&#x27;;// If you use CommonJS (i.e NodeJS environment), it should be:// const to = require(&#x27;await-to-js&#x27;).default;async function asyncTaskWithCb(cb) &#123;     let err, user, savedTask, notification;     [ err, user ] = await to(UserModel.findById(1));     if(!user) return cb(&#x27;No user found&#x27;);     [ err, savedTask ] = await to(TaskModel(&#123;userId: user.id, name: &#x27;Demo Task&#x27;&#125;));     if(err) return cb(&#x27;Error occurred while saving task&#x27;);    if(user.notificationsEnabled) &#123;       [ err ] = await to(NotificationService.sendNotification(user.id, &#x27;Task Created&#x27;));       if(err) return cb(&#x27;Error while sending notification&#x27;);    &#125;    if(savedTask.assignedUser.id !== user.id) &#123;       [ err, notification ] = await to(NotificationService.sendNotification(savedTask.assignedUser.id, &#x27;Task was created for you&#x27;));       if(err) return cb(&#x27;Error while sending notification&#x27;);    &#125;    cb(null, savedTask);&#125;async function asyncFunctionWithThrow() &#123;  const [err, user] = await to(UserModel.findById(1));  if (!user) throw new Error(&#x27;User not found&#x27;);  &#125;</span><br></pre></td></tr></table></figure>

<p>Composition API</p>
<h4 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h4><p>在template中不需要根元素包裹。</p>
<p>好处：减少标签层级，减少内存占用</p>
<h4 id="script差异"><a href="#script差异" class="headerlink" title="script差异"></a>script差异</h4><ul>
<li>可以再 <code>script</code> 使用 <code>ts</code> 只需 设置 <code>lang</code> 即可</li>
<li><code>defineComponent</code> 方法创建一个组件</li>
<li><code>export default</code> 直接导出一个组件</li>
</ul>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="teleport"><a href="#teleport" class="headerlink" title="teleport"></a>teleport</h2><p>首先谈谈适用场景：比如Dialog即希望在组件内部使用，又希望不要嵌套太深到子组件中。有些类似于element-ui中的append-to-body。将组建添加到body下面。</p>
<p>为什么需要这么做呢？我们都知道有时候我们的组件嵌套很深，Di alog的定位就不是很好定位。因此vue3给我们提供了teleport【传送门】，就是将你的组件放到你想要它待着的地方。</p>
<p>怎么使用呢？看下面：</p>
<p>1.首先在项目的index.html文件中提供一个挂在元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  &lt;div id=&quot;dialog&quot;&gt;&lt;/div&gt;&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p>2.然后定义一个Dialog组件：</p>
<p>注意to属性，一定是跟index.html中挂载元素的id一致：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;    &lt;teleport to=&quot;#dialog&quot;&gt;        &lt;div class=&quot;dialog&quot;&gt;            &lt;div class=&quot;dialog-wrapper&quot;&gt;                &lt;p&gt;暂无数据哦&lt;/p&gt;                &lt;p&gt; 请你稍等……&lt;/p&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/teleport&gt;&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>渲染之后，检查元素，你的Dialog组件就在app的同级了</p>
<img src="/Users/zlj/Library/Application Support/typora-user-images/image-20211007195037877.png" alt="image-20211007195037877" style="zoom:80%;" />

<h2 id="suspense"><a href="#suspense" class="headerlink" title="suspense"></a>suspense</h2><p>这个属性呢，可以帮助我们来控制前后端数据交互的异步过程中的加载动画。之前我们都是使用v-if控制。那么有啦suspense怎么做呢？</p>
<p>了解一下suspense的用法：它提供两个<code>template</code> slot, 刚开始会渲染一个 fallback 状态下的内容， 直到到达某个条件后才会渲染 default 状态的正式内容， 通过使用<code>Suspense</code>组件进行展示异步渲染就更加的简单。:::warning 如果使用 <code>Suspense</code>, 要返回一个 promise :::<code>Suspense</code> 组件的使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  &lt;Suspense&gt;        &lt;template #default&gt;            &lt;async-component&gt;&lt;/async-component&gt;        &lt;/template&gt;        &lt;template #fallback&gt;            &lt;div&gt;                Loading...            &lt;/div&gt;        &lt;/template&gt;  &lt;/Suspense&gt;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://qq-leaves.github.io/2021/10/15/vue3.0/" data-id="ckus36ij10000rdml3icy636o" data-title="vue3.0知识点" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
    
  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/10/15/vue3.0/">vue3.0知识点</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 叶子<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>